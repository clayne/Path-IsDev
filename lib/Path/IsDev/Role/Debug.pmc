# It was generated by macro::compiler version 0.06.
# Don't edit this file, edit Path/IsDev/Role/Debug.pm instead.
# ANY CHANGES MADE HERE WILL BE LOST!
# ============================= freshness check =============================
# the original file modified at Wed Jul 10 11:51:09 2013
BEGIN{my$o=$INC{q{Path/IsDev/Role/Debug.pm}}||q{Path/IsDev/Role/Debug.pm};my$m=(CORE::stat$o)[9];
if($m and $m != 1373413869){ my $f=do{CORE::open my$in,'<',$o or
die(qq{Cannot open $o: $!});local$/;<$in>;};require Filter::Util::Call;
Filter::Util::Call::filter_add(sub{ Filter::Util::Call::filter_del();
1 while Filter::Util::Call::filter_read();$_=$f;return 1; });}}
# line 1 Path/IsDev/Role/Debug.pm

use strict;
use warnings;

package Path::IsDev::Role::Debug;
use v5.10;
use Moo::Role;

require Scalar::Util;

#use macro _refaddr => sub { \&Scalar::Util::refaddr($_[0]) };
 
#    _need_scalar_util();
#    Scalar::Util::refaddr( $_[0] );
#};
#use macro _weaken => sub {
#    require Scalar::Util;
#    Scalar::Util::weaken( $_[0] );
#};

#use macro _blessed => sub {
#    require Scalar::Util;
#    Scalar::Util::blessed( $_[0] );
#};

#use macro class_from => sub {
#    do{no feature;use feature ':5.10';require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} ? do{no feature;use feature ':5.10';require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} : $_[0];
#};


use MooX::ClassAttribute;

class_has _debug_env_key => (
    is      => ro =>,
    lazy    => 1,
    builder => sub {
        my ($self) = @_;
        my $classname = do{no feature;use feature ':5.10';do {require Scalar::Util;&Scalar::Util::blessed(+($self))} ? do {require Scalar::Util;&Scalar::Util::blessed(+($self))} : +($self)};
        $classname = uc($classname);
        $classname =~ s/::/_/g;
        $classname .= '_DEBUG';
        return $classname;
    }
);

class_has '_debugging' => (
    is      => ro =>,
    lazy    => 1,
    builder => sub {
        my ($self) = @_;
        my $key = $self->_debug_env_key;
        return unless exists $ENV{$key};
        return !!$ENV{$key};
    },
);

our $REFADDR_TABLE = {};

#use macro class_refaddrs => sub {
#    my $class = do{no feature;use feature ':5.10';do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} ? do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} : +($_[0])};
#    ( ( exists $REFADDR_TABLE->{$class} ) ? (  $REFADDR_TABLE->{$class} ) : ( $REFADDR_TABLE->{$class} = {} ));
#};


our $INSTANCE_TABLE = {};

#use macro class_next_instance_id => sub {
#    my $class = do{no feature;use feature ':5.10';do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} ? do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} : +($_[0])};
#    exists $INSTANCE_TABLE->{$class} ? () :  ( $INSTANCE_TABLE->{$class} = 0 ); 
#    my $id = $INSTANCE_TABLE->{$class};
#    $INSTANCE_TABLE->{$class}++;
#    sprintf '%x', $id;
#};


#use macro instance_refaddr => sub {
#    sprintf '%x', do{no feature;use feature ':5.10';\(&Scalar::Util::refaddr(+($_[0])))};
#};


#use macro instance_id => sub {
#    my $addr   = do{no feature;use feature ':5.10';sprintf '%x', do {\(&Scalar::Util::refaddr(+($_[0])))}};
#    my $table  = do{no feature;use feature ':5.10';my $class = do {do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} ? do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} : +($_[0])};exists $$REFADDR_TABLE{$class} ? $$REFADDR_TABLE{$class} : ($$REFADDR_TABLE{$class} = {})};
#    (( exists $table->{$addr} ) ? ( $table->{$addr} ) : (  $table->{$addr} = do{no feature;use feature ':5.10';my $class = do {do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} ? do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} : +($_[0])};exists $$INSTANCE_TABLE{$class} ? () : ($$INSTANCE_TABLE{$class} = 0);my $id = $$INSTANCE_TABLE{$class};++$$INSTANCE_TABLE{$class};sprintf '%x', $id} ));
#};


sub _instance_id { do{no feature;use feature ':5.10';my $addr = do {sprintf '%x', do {\(&Scalar::Util::refaddr(+(@_)))}};my $table = do {my $class = do {do {require Scalar::Util;&Scalar::Util::blessed(+(@_))} ? do {require Scalar::Util;&Scalar::Util::blessed(+(@_))} : +(@_)};exists $$REFADDR_TABLE{$class} ? $$REFADDR_TABLE{$class} : ($$REFADDR_TABLE{$class} = {})};exists $$table{$addr} ? $$table{$addr} : ($$table{$addr} = do {my $class = do {do {require Scalar::Util;&Scalar::Util::blessed(+(@_))} ? do {require Scalar::Util;&Scalar::Util::blessed(+(@_))} : +(@_)};exists $$INSTANCE_TABLE{$class} ? () : ($$INSTANCE_TABLE{$class} = 0);my $id = $$INSTANCE_TABLE{$class};++$$INSTANCE_TABLE{$class};sprintf '%x', $id})} }

sub _instance_tag {
    my $id     = do{no feature;use feature ':5.10';my $addr = do {sprintf '%x', do {\(&Scalar::Util::refaddr(+($_[0])))}};my $table = do {my $class = do {do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} ? do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} : +($_[0])};exists $$REFADDR_TABLE{$class} ? $$REFADDR_TABLE{$class} : ($$REFADDR_TABLE{$class} = {})};exists $$table{$addr} ? $$table{$addr} : ($$table{$addr} = do {my $class = do {do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} ? do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} : +($_[0])};exists $$INSTANCE_TABLE{$class} ? () : ($$INSTANCE_TABLE{$class} = 0);my $id = $$INSTANCE_TABLE{$class};++$$INSTANCE_TABLE{$class};sprintf '%x', $id})};
    my $class  = do{no feature;use feature ':5.10';do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} ? do {require Scalar::Util;&Scalar::Util::blessed(+($_[0]))} : +($_[0])};
    return qq{$class=$id};
}

sub _instance_debug {
    my ( $self, $message ) = @_;
        return unless $self->_debugging;
        return *STDERR->printf( qq{[%s] %s\n}, $self->_instance_tag, $message );
}

our $INSTANCE_MAXES = {};

sub _class_attr_padname {
    my ( $self, $attr ) = @_;
    my $class = do{no feature;use feature ':5.10';do {require Scalar::Util;&Scalar::Util::blessed(+($self))} ? do {require Scalar::Util;&Scalar::Util::blessed(+($self))} : +($self)};
    my $alen  = length $attr;
    if ( not exists $INSTANCE_MAXES->{$class} ) {
        $INSTANCE_MAXES->{$class} = $alen;
        return $attr;
    }
    $INSTANCE_MAXES->{$class} = $alen if $INSTANCE_MAXES->{$class} < $alen;
    return $attr . ( ' ' x ( $INSTANCE_MAXES->{$class} - $alen ) );
}

sub _instance_debug_prop_line {
    my ( $self, $name ) = @_;
    my $has_form = "has_$name";
    if ( $self->can($has_form) and not $self->$has_form ) {
        return;
    }
    my $formatted = $self->_class_attr_padname($name) . ' => ';
    my $value     = $self->$name;
    if ( not defined $value ) {
        return $formatted . 'undef';
    }
    if ( not ref $value ) {
        return $formatted . $value;
    }
    require Scalar::Util;
    my $bless = Scalar::Util::blessed($value);
    if ( not $bless ) {
        return $formatted . $value;
    }
    if ( $value->can('_instance_tag') ) {
        return $formatted . $value->_instance_tag;
    }
    return $formatted . $value;
}

